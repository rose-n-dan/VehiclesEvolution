\hypertarget{namespaceutils}{}\section{utils Namespace Reference}
\label{namespaceutils}\index{utils@{utils}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ b2\+Polygon\+Shape $>$ \hyperlink{namespaceutils_ad56cbd0c7a6e813a5dd523bbaabb55a4}{apply\+Tessellation} (const std\+::vector$<$ b2\+Vec2 $>$ \&polyline)
\item 
bool \hyperlink{namespaceutils_a1fe70cdae64372e591da8985d7a884d6}{is\+Nearly\+Zero} (double value, double precision)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
The library implements a modified ear slicing algorithm for polygon triangulation It is optimized by z-\/order curve hashing and extended to handle holes, twisted polygons, degeneracies and self-\/intersections. It works in a way that doesn\textquotesingle{}t guarantee correctness of triangulation, but attempts to always produce acceptable results for practical data. It\textquotesingle{}s based on ideas from F\+I\+ST\+: Fast Industrial-\/\+Strength Triangulation of Polygons by Martin Held Triangulation by Ear Clipping by David Eberly. 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespaceutils_ad56cbd0c7a6e813a5dd523bbaabb55a4}\label{namespaceutils_ad56cbd0c7a6e813a5dd523bbaabb55a4}} 
\index{utils@{utils}!apply\+Tessellation@{apply\+Tessellation}}
\index{apply\+Tessellation@{apply\+Tessellation}!utils@{utils}}
\subsubsection{\texorpdfstring{apply\+Tessellation()}{applyTessellation()}}
{\footnotesize\ttfamily std\+::vector$<$ b2\+Polygon\+Shape $>$ utils\+::apply\+Tessellation (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ b2\+Vec2 $>$ \&}]{polyline }\end{DoxyParamCaption})}



Definition at line 19 of file Utils.\+cpp.


\begin{DoxyCode}
19                                                                                \{
20     \textcolor{comment}{// The number type to use for tessellation}
21     \textcolor{keyword}{using} Coord = double;
22     \textcolor{keyword}{using} N = uint32\_t;
23     \textcolor{keyword}{using} Point = std::array<Coord, 2>;
24     std::vector<std::vector<Point>> polygon;
25     std::vector<Point> points;
26 
27     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto} &point : polyline) \{
28         points.push\_back(\{point.x, point.y\});
29     \}
30 
31     polygon.push\_back(points);
32 
33     std::vector<N> indices = mapbox::earcut<N>(polygon);
34 
35     \textcolor{keywordflow}{if} (indices.size() % 3 != 0) \{
36         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"Ear cutting algorithm failed!"});
37     \}
38 
39     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} i = 0;
40 
41     std::vector<b2PolygonShape> map\_shape;
42 
43     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = indices.begin(); it != indices.end(); it += 3)
44     \{
45         map\_shape.emplace\_back();
46 
47         b2Vec2 triangle[3];
48         Point point = points.at(*it);
49         triangle[0] = b2Vec2(static\_cast<float32>(point[0]), static\_cast<float32>(point[1]));
50         point = points.at(*(it + 1));
51         triangle[1] = b2Vec2(static\_cast<float32>(point[0]), static\_cast<float32>(point[1]));
52         point = points.at(*(it + 2));
53         triangle[2] = b2Vec2(static\_cast<float32>(point[0]), static\_cast<float32>(point[1]));
54 
55         map\_shape.at(i).Set(triangle, 3);
56         ++i;
57     \}
58 
59     \textcolor{keywordflow}{return} map\_shape;
60 \}
\end{DoxyCode}
\mbox{\Hypertarget{namespaceutils_a1fe70cdae64372e591da8985d7a884d6}\label{namespaceutils_a1fe70cdae64372e591da8985d7a884d6}} 
\index{utils@{utils}!is\+Nearly\+Zero@{is\+Nearly\+Zero}}
\index{is\+Nearly\+Zero@{is\+Nearly\+Zero}!utils@{utils}}
\subsubsection{\texorpdfstring{is\+Nearly\+Zero()}{isNearlyZero()}}
{\footnotesize\ttfamily bool utils\+::is\+Nearly\+Zero (\begin{DoxyParamCaption}\item[{double}]{value,  }\item[{double}]{precision }\end{DoxyParamCaption})}



Definition at line 62 of file Utils.\+cpp.


\begin{DoxyCode}
62                                                   \{
63     \textcolor{keywordflow}{return} value < precision && value > -precision;
64 \}
\end{DoxyCode}
